MAX_HANDLES:        equ 4               ; Maximum allowed handles (sowwy)
                                        ; Make sure to update GetHandlePtr!

;****************************************************************************
; Status of a handle
;****************************************************************************

                    rsreset
HANDLE_MODE:        rs.b 1              ; Handle mode (see HMODE_*)
HANDLE_FS:          rs.b 1              ; Filesystem (see FILESYS_*)
HANDLE_ADDR:        rs.l 1              ; Address within filesystem
HANDLE_POS:         rs.l 1              ; Current position in bytes
HANDLE_LEN:         rs.l 1              ; File length in bytes

HANDLE_SIZE:        rs.b 0              ; Size of handle data

;****************************************************************************
; Possible modes in which a handle may be open
;****************************************************************************

                    rsreset
                    rs.b 1              ; Not in use
HMODE_ERROR:        rs.b 1              ; Unusable (EOF?)
HMODE_READ:         rs.b 1              ; For reading (file)
HMODE_READDIR:      rs.b 1              ; For reading (directory)
HMODE_WRITE:        rs.b 1              ; For writing (file)
HMODE_WRITEDIR:     rs.b 1              ; For writing (directory)

;****************************************************************************
; Possible filesystems
;****************************************************************************

                    rsreset
                    rs.b 1              ; Invalid
FILESYS_ROOT:       rs.b 1              ; Root directory
FILESYS_ROM:        rs.b 1              ; ROM filesystem

;****************************************************************************
; GetHandlePtr [macro]
; Converts a handle ID to a pointer.
;----------------------------------------------------------------------------
; input d7.w .... Handle ID
;----------------------------------------------------------------------------
; output a6.l ... Handle pointer
;----------------------------------------------------------------------------
; breaks: d7
;****************************************************************************

GetHandlePtr: macro
    and.w   #$FF, d7
    add.w   d7, d7
    add.w   d7, d7
    lea     HandlePtrTable(pc), a6
    move.l  (a6,d7.w), a6
    endm

;----------------------------------------------------------------------------

HandlePtrTable:
    dc.l    0
    dc.l    Handles+HANDLE_SIZE*0
    dc.l    Handles+HANDLE_SIZE*1
    dc.l    Handles+HANDLE_SIZE*2
    dc.l    Handles+HANDLE_SIZE*3

;****************************************************************************
; InitHandles
; Initializes the file handles.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

InitHandles:
    lea     (Handles), a6               ; Mark all handles as free
    moveq   #MAX_HANDLES-1, d7
@Loop:
    clr.b   HANDLE_MODE(a6)
    lea     HANDLE_SIZE(a6), a6
    dbf     d7, @Loop
    
    rts                                 ; End of subroutine

;****************************************************************************
; OpenDir
; Opens a directory for reading its entries.
;----------------------------------------------------------------------------
; input a6.l .... Pointer to filename
;----------------------------------------------------------------------------
; output d7.b ... Handle ID (0 on failure)
;----------------------------------------------------------------------------
; breaks: d5-d6, a4-a6
;****************************************************************************

OpenDir:
    cmpi.b  #'/', (a6)+                 ; Absolute paths only, sorry
    bne.s   @Error
    
    tst.b   (a6)                        ; Open "/"?
    beq     @Root
    
    move.b  (a6)+, -(sp)                ; Get next four characters
    move.w  (sp)+, d7
    move.b  (a6)+, d7
    swap    d7
    move.b  (a6)+, -(sp)
    move.w  (sp)+, d7
    move.b  (a6)+, d7
    
    cmp.l   #'rom'<<8, d7               ; Open "/rom"?
    beq     @RomRoot

;----------------------------------------------------------------------------

@Error:
    moveq   #0, d7                      ; For now not supported, sorry
    moveq   #0, d6
    moveq   #0, d5
    move.l  d7, a6
    move.l  d7, a5
    move.l  d7, a4
    
    rts                                 ; End of subroutine

;----------------------------------------------------------------------------

@Root:
    bsr     AllocHandle                 ; Get a new handle
    move.l  a6, d6
    beq     @Error
    
    move.b  #HMODE_READDIR, HANDLE_MODE(a6) ; Set up handle
    move.b  #FILESYS_ROOT, HANDLE_FS(a6)
    bra     @Success

;----------------------------------------------------------------------------

@RomRoot:
    bsr     AllocHandle                 ; Get a new handle
    move.l  a6, d6
    beq     @Error
    
    move.b  #HMODE_READDIR, HANDLE_MODE(a6) ; Set up handle
    move.b  #FILESYS_ROM, HANDLE_FS(a6)
    move.l  #RomFilesystem, HANDLE_ADDR(a6)

;----------------------------------------------------------------------------

@Success:
    moveq   #0, d6                      ; Clear up registers
    moveq   #0, d5
    move.l  d6, a6
    move.l  d6, a5
    move.l  d6, a4
    
    rts                                 ; End of subroutine

;****************************************************************************
; ReadDir
; Reads the next file entry from a directory.
;----------------------------------------------------------------------------
; input d7.b .... Handle ID
;----------------------------------------------------------------------------
; output a6.l ... Pointer to filename
; output d7.w ... File attributes
; output d6.l ... Filesize in bytes
;----------------------------------------------------------------------------
; breaks: d5, a4-a5
;****************************************************************************

ReadDir:
    GetHandlePtr                        ; Convert ID to pointer
    
    move.l  a6, d7                      ; Valid handler?
    beq.s   @Error
    cmpi.b  #HMODE_READDIR, HANDLE_MODE(a6)
    bne.s   @Error
    
    moveq   #0, d7                      ; Ask the filesystem driver to
    move.b  HANDLE_FS(a6), d7           ; read a directory entry
    add.w   d7, d7
    add.w   d7, d7
    lea     @Handlers(pc), a5
    jsr     (a5,d7.w)
    
    cmp.w   #$FFFF, d7                  ; Are there more entries?
    beq.s   @Error
    
    move.l  a5, a6                      ; We want the filename here
    
    moveq   #0, d5                      ; Just in case (don't accidentally
    move.l  d5, a5                      ; leak internal information)
    move.l  d5, a4
    
    rts                                 ; End of subroutine

;----------------------------------------------------------------------------

@Error:
    moveq   #-1, d7                     ; Return reasonable values
    moveq   #0, d6
    moveq   #0, d5
    move.l  d6, a4
    move.l  d6, a5
    move.l  d6, a6
    
    rts                                 ; End of subroutine

;----------------------------------------------------------------------------

@Handlers:
    bra.w   @Dummy
    bra.w   RootFS_ReadDir              ; FILESYS_ROOT
    bra.w   RomFS_ReadDir               ; FILESYS_ROM

@Dummy:
    moveq   #-1, d7                     ; Return "no entry"
    rts                                 ; End of dummy handler

;****************************************************************************
; AllocHandle
; Allocates a file handle.
;----------------------------------------------------------------------------
; output a6.l ... Pointer to handle (0 on failure)
; output d7.w ... Handle ID
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a5
;****************************************************************************

AllocHandle:
    lea     (Handles), a6               ; Scan for a free handle
    moveq   #MAX_HANDLES-1, d6
    moveq   #1, d7
@Loop:
    tst.b   HANDLE_MODE(a6)
    beq.s   @Found
    lea     HANDLE_SIZE(a6), a6
    addq.w  #1, d7
    dbf     d6, @Loop
    
    move.l  #0, a6                      ; No free handle
    moveq   #0, d7
    
    rts                                 ; End of subroutine

;----------------------------------------------------------------------------

@Found:
    move.b  #HMODE_ERROR, HANDLE_MODE(a6)   ; Initialize handle
    clr.b   HANDLE_FS(a6)
    clr.l   HANDLE_ADDR(a6)
    clr.l   HANDLE_POS(a6)
    clr.l   HANDLE_LEN(a6)
    
    rts                                 ; End of subroutine

;****************************************************************************
; The functions below are from Indigo 0.10 and may be replaced by proper
; alternatives once the filesystem support is working properly. Should have
; thought twice about it >_>;
;****************************************************************************

;****************************************************************************
; ScanForFile
; Scans for a file entry in a directory.
;----------------------------------------------------------------------------
; input a6.l .... Pointer to directory data
; input a5.l .... Pointer to filename
;----------------------------------------------------------------------------
; output d7.w ... File properties ($FFFF if entry not found)
; output d6.l ... File address (in clusters)
; output d5.l ... File size (in bytes)
;----------------------------------------------------------------------------
; breaks: a4-a6
;----------------------------------------------------------------------------
; notes: directory data must be aligned to a cluster size!! (ideally being
; read directly from ROM/SRAM)
;****************************************************************************

ScanForFile:
@Loop:
    move.w  (a6)+, d7                   ; End of directory?
    cmp.w   #$FFFF, d7
    bne.s   @NotEnd
    moveq   #-1, d7
    moveq   #-1, d6
    moveq   #-1, d5
    rts
    
@NotEnd:
    move.w  d7, -(sp)                   ; Store this entry's properties
    move.w  (a6)+, -(sp)
    move.l  (a6)+, -(sp)
    
    move.l  a5, a4                      ; Check if filename matches
    moveq   #'/', d6
@CompareLoop:
    move.b  (a4)+, d7
    cmp.b   d6, d7
    bne.s   @NotSlash
    moveq   #0, d7
@NotSlash:
    cmp.b   (a6)+, d7
    bne.s   @NotMatch
    tst.b   d7
    beq.s   @Match
    bra.s   @CompareLoop

@NotMatch:
    addq.w  #8, sp                      ; Get rid of the saved properties
    
    subq.l  #1, a6                      ; Skip rest of filename
@SkipName:
    tst.b   (a6)+
    bne.s   @SkipName
    
    move.l  a6, d7                      ; Move onto the next block
    subq.l  #1, d7
    or.w    #$07, d7
    addq.l  #1, d7
    move.l  d7, a6
    
    bra.s   @Loop

;----------------------------------------------------------------------------

@Match:
    moveq   #0, d6                      ; Retrieve entry properties
    move.l  (sp)+, d5
    move.w  (sp)+, d6
    move.w  (sp)+, d7
    
    rts                                 ; End of subroutine
