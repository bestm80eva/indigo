MAX_HANDLES:        equ 4               ; Maximum files that can be opened

;****************************************************************************
; Data for a file handle
;****************************************************************************

                    rsreset

HANDLE_OPEN:        rs.b 1              ; Set if file handle is in use
HANDLE_MODE:        rs.b 1              ; Mode (er, just see HMODE_*)
HANDLE_PTR:         rs.l 1              ; Pointer to file data in filesystem
HANDLE_LEN:         rs.l 1              ; File length in bytes

HANDLE_SIZE:        rs.b 0              ; Size of file handle data

;****************************************************************************
; Possible file handle modes
;****************************************************************************

                    rsreset

                    rs.b 1              ; Unusable handle (EOF?)
HMODE_DIR:          rs.b 1              ; Scanning directory

;****************************************************************************
; AllocHandle
; Allocates a new file handle.
;----------------------------------------------------------------------------
; output d7.b ... File handle ID (-1 on failure)
; output a6.l ... Pointer to handle (0 on failure)
;----------------------------------------------------------------------------
; breaks: d5-d6, a4-a5
;****************************************************************************

AllocHandle:
    lea     (Handles), a6               ; Test all handle slots to see if
    moveq   #MAX_HANDLES-1, d7          ; any of them isn't open yet
@Loop:
    tst.b   HANDLE_OPEN(a6)
    beq.s   @Free
    lea     HANDLE_SIZE(a6), a6
    dbf     d7, @Loop
    
    move.w  #0, a6                      ; No handle found
    moveq   #-1, d7
    rts                                 ; End of subroutine

;----------------------------------------------------------------------------

@Free:
    st.b    HANDLE_OPEN(a6)             ; Initialize handle
    clr.b   HANDLE_MODE(a6)
    clr.l   HANDLE_PTR(a6)
    clr.l   HANDLE_LEN(a6)
    
    neg.w   d7                          ; Get the handle ID
    add.w   #MAX_HANDLES-1, d7
    rts                                 ; End of subroutine

;****************************************************************************
; ScanForFile
; Scans for a file entry in a directory.
;----------------------------------------------------------------------------
; input a6.l .... Pointer to directory data
; input a5.l .... Pointer to filename
;----------------------------------------------------------------------------
; output d7.w ... File properties ($FFFF if entry not found)
; output d6.l ... File address (in clusters)
; output d5.l ... File size (in bytes)
;----------------------------------------------------------------------------
; breaks: a4-a6
;----------------------------------------------------------------------------
; notes: directory data must be aligned to a cluster size!! (ideally being
; read directly from ROM/SRAM)
;****************************************************************************

ScanForFile:
@Loop:
    move.w  (a6)+, d7                   ; End of directory?
    cmp.w   #$FFFF, d7
    bne.s   @NotEnd
    moveq   #-1, d7
    moveq   #-1, d6
    moveq   #-1, d5
    rts
    
@NotEnd:
    move.w  d7, -(sp)                   ; Store this entry's properties
    move.w  (a6)+, -(sp)
    move.l  (a6)+, -(sp)
    
    move.l  a5, a4                      ; Check if filename matches
    moveq   #'/', d6
@CompareLoop:
    move.b  (a4)+, d7
    cmp.b   d6, d7
    bne.s   @NotSlash
    moveq   #0, d7
@NotSlash:
    cmp.b   (a6)+, d7
    bne.s   @NotMatch
    tst.b   d7
    beq.s   @Match
    bra.s   @CompareLoop

@NotMatch:
    addq.w  #8, sp                      ; Get rid of the saved properties
    
    subq.l  #1, a6                      ; Skip rest of filename
@SkipName:
    tst.b   (a6)+
    bne.s   @SkipName
    
    move.l  a6, d7                      ; Move onto the next block
    subq.l  #1, d7
    or.w    #$07, d7
    addq.l  #1, d7
    move.l  d7, a6
    
    bra.s   @Loop

;----------------------------------------------------------------------------

@Match:
    moveq   #0, d6                      ; Retrieve entry properties
    move.l  (sp)+, d5
    move.w  (sp)+, d6
    move.w  (sp)+, d7
    
    rts                                 ; End of subroutine
