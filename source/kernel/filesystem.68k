MAX_HANDLES:        equ 4               ; Maximum allowed handles (sowwy)

;****************************************************************************
; Status of a handle
;****************************************************************************

                    rsreset
HANDLE_MODE:        rs.b 1              ; Handle mode (see HMODE_*)
HANDLE_FS:          rs.b 1              ; Filesystem (see FILESYS_*)
HANDLE_ADDR:        rs.l 1              ; Address within filesystem
HANDLE_POS:         rs.l 1              ; Current position in bytes
HANDLE_LEN:         rs.l 1              ; File length in bytes

HANDLE_SIZE:        rs.b 0              ; Size of handle data

;****************************************************************************
; Possible modes in which a handle may be open
;****************************************************************************

                    rsreset
                    rs.b 1              ; Not in use
HMODE_ERROR:        rs.b 1              ; Unusable (EOF?)
HMODE_READ:         rs.b 1              ; For reading (file)
HMODE_READDIR:      rs.b 1              ; For reading (directory)
HMODE_WRITE:        rs.b 1              ; For writing (file)
HMODE_WRITEDIR:     rs.b 1              ; For writing (directory)

;****************************************************************************
; Possible filesystems
;****************************************************************************

                    rsreset
                    rs.b 1              ; Invalid
FILESYS_ROOT:       rs.b 1              ; Root directory
FILESYS_ROM:        rs.b 1              ; ROM filesystem

;****************************************************************************
; AllocHandle
; Allocates a file handle.
;----------------------------------------------------------------------------
; output a6.l ... Pointer to handle (0 on failure)
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a5
;****************************************************************************

AllocHandle:
    lea     (Handles), a6               ; Scan for a free handle
    moveq   #MAX_HANDLES-1, d7
@Loop:
    tst.b   HANDLE_MODE(a6)
    beq.s   @Found
    lea     HANDLE_SIZE(a6), a6
    dbf     d7, @Loop
    
    move.l  #0, a6                      ; No free handle
    rts                                 ; End of subroutine

;----------------------------------------------------------------------------

@Found:
    move.b  #HMODE_ERROR, HANDLE_MODE(a6)   ; Initialize handle
    clr.b   HANDLE_FS(a6)
    clr.l   HANDLE_ADDR(a6)
    clr.l   HANDLE_POS(a6)
    clr.l   HANDLE_LEN(a6)
    
    rts                                 ; End of subroutine

;****************************************************************************
; The functions below are from Indigo 0.10 and may be replaced by proper
; alternatives once the filesystem support is working properly. Should have
; thought twice about it >_>;
;****************************************************************************

;****************************************************************************
; ScanForFile
; Scans for a file entry in a directory.
;----------------------------------------------------------------------------
; input a6.l .... Pointer to directory data
; input a5.l .... Pointer to filename
;----------------------------------------------------------------------------
; output d7.w ... File properties ($FFFF if entry not found)
; output d6.l ... File address (in clusters)
; output d5.l ... File size (in bytes)
;----------------------------------------------------------------------------
; breaks: a4-a6
;----------------------------------------------------------------------------
; notes: directory data must be aligned to a cluster size!! (ideally being
; read directly from ROM/SRAM)
;****************************************************************************

ScanForFile:
@Loop:
    move.w  (a6)+, d7                   ; End of directory?
    cmp.w   #$FFFF, d7
    bne.s   @NotEnd
    moveq   #-1, d7
    moveq   #-1, d6
    moveq   #-1, d5
    rts
    
@NotEnd:
    move.w  d7, -(sp)                   ; Store this entry's properties
    move.w  (a6)+, -(sp)
    move.l  (a6)+, -(sp)
    
    move.l  a5, a4                      ; Check if filename matches
    moveq   #'/', d6
@CompareLoop:
    move.b  (a4)+, d7
    cmp.b   d6, d7
    bne.s   @NotSlash
    moveq   #0, d7
@NotSlash:
    cmp.b   (a6)+, d7
    bne.s   @NotMatch
    tst.b   d7
    beq.s   @Match
    bra.s   @CompareLoop

@NotMatch:
    addq.w  #8, sp                      ; Get rid of the saved properties
    
    subq.l  #1, a6                      ; Skip rest of filename
@SkipName:
    tst.b   (a6)+
    bne.s   @SkipName
    
    move.l  a6, d7                      ; Move onto the next block
    subq.l  #1, d7
    or.w    #$07, d7
    addq.l  #1, d7
    move.l  d7, a6
    
    bra.s   @Loop

;----------------------------------------------------------------------------

@Match:
    moveq   #0, d6                      ; Retrieve entry properties
    move.l  (sp)+, d5
    move.w  (sp)+, d6
    move.w  (sp)+, d7
    
    rts                                 ; End of subroutine
