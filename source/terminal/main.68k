EntryPoint:
    moveq   #0, d7                      ; Load graphics
    move.w  #NumPatterns, d6
    lea     Patterns(pc), a6
    syscall OS_LOADPATTERNS
    moveq   #1, d7
    lea     AltPalette(pc), a6
    syscall OS_LOADPALETTE
    
    lea     Layout(pc), a6              ; Load interface
    syscall OS_PARSELAYOUT
    
    syscall OS_ALLOCSPRITE              ; Allocate sprite for the cursor
    move.b  d7, (CursorSprite)
    
;----------------------------------------------------------------------------

    moveq   #0, d7                      ; Draw monitor
    moveq   #0, d6
    moveq   #0, d5
    move.w  #40, a6
    move.w  #25, a5
    move.w  #VramBorder+$A000, a4
    syscall OS_FILLTILES

    moveq   #1, d7                      ; Draw monitor frame
    moveq   #1, d6
    moveq   #0, d5
    move.w  #36, a6
    move.w  #21, a5
    move.w  #VramFrame+$A000, a4
    syscall OS_FILLFRAME
    
    moveq   #2, d7                      ; Draw text mode graphics
    moveq   #0, d6
    moveq   #1, d5
    move.w  #36, a6
    move.w  #32, a5
    move.w  #VramScreen+$2000, a4
    syscall OS_DRAWTILES
    
    move.w  #VramScreen, d7
    move.w  #36*NUM_ROWS, d6
    moveq   #$0E, d5
    syscall OS_FILLPATTERNS

;----------------------------------------------------------------------------

    clr.b   (CursorX)                   ; Set up console
    clr.b   (CursorY)
    clr.b   (CursorBlink)
    bsr     ClearInput
    bsr     ClearBuffer
    
    bsr     ShowVersion
    bsr     ShowMemory
    
    lea     @Message1(pc), a6           ; Sowwy!
    bsr     PrintLine
    lea     @Message2(pc), a6
    bsr     PrintLine
    bsr     PrintBlank
    
    bra     MainLoop

@Message1:  dc.b 'Sorry!! Terminal currently out of order', 0
@Message2:  dc.b 'Please wait for commands to be implemented :)', 0
            even

;----------------------------------------------------------------------------

MainLoop:
    bsr     PrintInput                  ; Update the screen
    bsr     UpdateCursor
    
    syscall OS_GUILOOP                  ; Wait for an event
    
    and.w   #$FF, d7                    ; Handle the event
    lsl.w   #2, d7
    lea     @Handlers(pc), a6
    jsr     (a6,d7.w)
    
    bra.s   MainLoop                    ; Keep going

;----------------------------------------------------------------------------

@Handlers:
    bra.w   DoCursorBlink
    bra.w   GotAscii

;****************************************************************************
; RunCommand
; Runs the entered command.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

RunCommand:
    bsr     AdvanceLine                 ; Leave the command line alone
    
    lea     (InputBuffer), a6           ; Erase excess whitespace
    move.l  a6, a5
    moveq   #$20, d6
    moveq   #1, d7
@SpaceLoop:
    move.b  (a6)+, d6
    beq.s   @SpaceEnd
    cmp.b   #$20, d6
    beq.s   @SpaceBlank
    moveq   #0, d7
@SpaceGraph:
    move.b  d6, (a5)+
    bra.s   @SpaceLoop
@SpaceBlank:
    move.w  d7, d5
    moveq   #1, d7
    tst.w   d5
    beq.s   @SpaceGraph
    bra.s   @SpaceLoop
@SpaceEnd:
    clr.b   (a5)
    
    tst.b   (InputBuffer)               ; Ignore empty lines
    bne.s   @HasCommand
    st.b    (InputDirty)
    rts
@HasCommand:
    
    lea     @Invalid(pc), a6            ; ¯\_(ツ)_/¯
    bsr     PrintLine
    
    bsr     ClearInput                  ; Erase any entered text now
    bsr     PrintBlank                  ; For spacing purposes
    rts                                 ; End of subroutine

;----------------------------------------------------------------------------

@Invalid:   dc.b 'Eh?',0
            even
