EntryPoint:
    moveq   #0, d7                      ; Load graphics
    move.w  #NumPatterns, d6
    lea     Patterns(pc), a6
    syscall OS_LOADPATTERNS
    moveq   #1, d7
    lea     AltPalette(pc), a6
    syscall OS_LOADPALETTE
    
    lea     Layout(pc), a6              ; Load interface
    syscall OS_PARSELAYOUT
    
    syscall OS_ALLOCSPRITE              ; Allocate sprite for the cursor
    move.b  d7, (CursorSprite)
    
;----------------------------------------------------------------------------

    moveq   #0, d7                      ; Draw monitor
    moveq   #0, d6
    moveq   #0, d5
    move.w  #40, a6
    move.w  #25, a5
    move.w  #VramBorder+$A000, a4
    syscall OS_FILLTILES

    moveq   #1, d7                      ; Draw monitor frame
    moveq   #1, d6
    moveq   #0, d5
    move.w  #36, a6
    move.w  #21, a5
    move.w  #VramFrame+$A000, a4
    syscall OS_FILLFRAME
    
    moveq   #2, d7                      ; Draw text mode graphics
    moveq   #0, d6
    moveq   #1, d5
    move.w  #36, a6
    move.w  #32, a5
    move.w  #VramScreen+$2000, a4
    syscall OS_DRAWTILES
    
    move.w  #VramScreen, d7
    move.w  #36*NUM_ROWS, d6
    moveq   #$0E, d5
    syscall OS_FILLPATTERNS

;----------------------------------------------------------------------------

    clr.b   (CursorX)                   ; Set up console
    clr.b   (CursorY)
    clr.b   (CursorBlink)
    bsr     ClearBuffer
    
    bsr     ShowVersion
    bsr     ShowMemory
    
    lea     @Message1(pc), a6           ; Sowwy!
    bsr     PrintLine
    lea     @Message2(pc), a6
    bsr     PrintLine
    bsr     PrintBlank
    
    bsr     ClearBuffer                 ; Render a fake prompt
    lea     @Prompt(pc), a6
    bsr     AddText
    bsr     RenderText
    
    bra     MainLoop

@Message1:  dc.b 'Sorry!! Terminal currently out of order', 0
@Message2:  dc.b 'Please wait for keyboard support :)', 0
@Prompt:    dc.b '>', 0
            even

;----------------------------------------------------------------------------

MainLoop:
    bsr     UpdateCursor                ; Position the cursor
    syscall OS_GUILOOP                  ; Wait for an event
    
    and.w   #$FF, d7                    ; Handle the event
    lsl.w   #2, d7
    lea     @Handlers(pc), a6
    jsr     (a6,d7.w)
    
    bra.s   MainLoop                    ; Keep going

;----------------------------------------------------------------------------

@Handlers:
    bra.w   DoCursorBlink
    bra.w   KeyDownTest
    bra.w   KeyUpTest
    bra.w   AsciiTest

;****************************************************************************
; DoCursorBlink
; Handler for the timer, used to blink the cursor.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

DoCursorBlink:
    not.b   (CursorBlink)
    rts

;****************************************************************************
; KeyDownTest, KeyUpTest
; Test routines for key events.
;----------------------------------------------------------------------------
; input d6.w ... Key scancode and flags
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

KeyDownTest:
    lea     @Message(pc), a0
    bra     KeyTest
@Message:
    dc.b ' pressed', 0
    even

KeyUpTest:
    lea     @Message(pc), a0
    bra     KeyTest
@Message:
    dc.b ' released', 0
    even

;----------------------------------------------------------------------------

KeyTest:
    move.b  d6, d0                      ; Separate scancode and flags
    move.w  d6, -(sp)
    move.b  (sp)+, d1
    
    bsr     ClearBuffer                 ; Draw beginning of message
    lea     @KeyNo(pc), a6
    bsr     AddText
    
    moveq   #0, d7                      ; Draw key scancode
    move.b  d0, d7
    lea     -12(sp), sp
    move.l  sp, a6
    syscall OS_INT2ASCII
    move.l  sp, a6
    bsr     AddText
    lea     12(sp), sp
    
    move.l  a0, a6                      ; Draw pressed/released
    bsr     AddText
    
    bsr     FlushLine                   ; Done here
    bsr     ClearBuffer
    bra     RenderText

;----------------------------------------------------------------------------

@KeyNo:             dc.b 'Key #', 0
                    even

;****************************************************************************
; AsciiTest
; Test routines for ASCII events.
;----------------------------------------------------------------------------
; input d6.w ... ASCII code and flags
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

AsciiTest:
    move.w  d6, d0
    
    bsr     ClearBuffer                 ; Draw beginning of message
    lea     @Message(pc), a6
    bsr     AddText
    
    lsl.w   #8, d0                      ; Draw ASCII character
    move.w  d0, -(sp)
    move.l  sp, a6
    bsr     AddText
    addq.w  #2, sp
    
    bsr     FlushLine                   ; Done here
    bsr     ClearBuffer
    bra     RenderText

;----------------------------------------------------------------------------

@Message:           dc.b 'ASCII character ',0
                    even
