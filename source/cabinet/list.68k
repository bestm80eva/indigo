FLIST_W:            equ 22              ; Width of list in tiles
FLIST_H:            equ 18              ; Height of list in tiles
FLIST_X:            equ 4               ; X coordinate of list
FLIST_Y:            equ 5               ; Y coordinate of list

;****************************************************************************
; ClearFileList
; Clears the file list.
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

ClearFileList:
    moveq   #0, d7                      ; Clear string offsets
    lea     (FileListPtr), a6
    moveq   #4-1, d6
@ClearOffsets:
    move.l  d7, (a6)+
    move.l  d7, (a6)+
    move.l  d7, (a6)+
    move.l  d7, (a6)+
    dbf     d6, @ClearOffsets
    
    clr.w   (FileListLast)              ; Set up offsets for new entries
    move.w  #FileList&$FFFF, (FileListNext)
    
    clr.l   (FileList)                  ; Make sure the list is empty
    clr.w   (FileList+4)
    clr.w   (NumFiles)
    rts                                 ; End of subroutine

;****************************************************************************
; AddFileEntry
; Adds a filename to the file list.
;----------------------------------------------------------------------------
; input a6.l ... Pointer to filename
; input d7.b ... Icon to show
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

AddFileEntry:
    moveq   #-1, d6                     ; Get pointer to new and last entries
    move.w  (FileListNext), d6
    move.l  d6, a5
    move.w  (FileListLast), d6
    move.l  d6, a4
    
    tst.w   d6                          ; Link the two entries
    beq.s   @NoLastEntry
    move.w  (FileListNext), 2(a4)
@NoLastEntry:
    move.w  (FileListLast), (a5)+
    clr.w   (a5)+
    
    move.b  d7, (a5)+                   ; Store icon
    move.b  #$20, (a5)+                 ; Store padding space
    
@CopyFilename:                          ; Store filename
    move.b  (a6)+, (a5)+
    bne.s   @CopyFilename
    
    move.w  a5, d7                      ; Pad to an even size if needed
    and.w   #1, d7
    beq.s   @NoPadding
    clr.b   (a5)+
@NoPadding:
    
    move.w  (FileListNext), (FileListLast)  ; Update offsets for inserting
    move.w  a5, (FileListNext)              ; the next entry
    
    addq.w  #1, (NumFiles)              ; Update file count
    rts                                 ; End of subroutine

;****************************************************************************
; RefreshList
; Redraws the whole file list.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

RefreshList:
    clr.w   (ScrollPos)                 ; Reset scroll position
    
    lea     (FileListPtr), a0           ; Cache the offsets to the entries
    lea     (FileList), a1              ; at the beginning of the list
    move.w  (NumFiles), d7
    beq.s   @NoFiles
    cmp.w   #FLIST_H, d7
    blo.s   @ShortScan
    moveq   #FLIST_H, d7
@ShortScan:
    subq.w  #1, d7
    move.w  d7, d1
    moveq   #-1, d0
@ScanFiles:
    move.w  a1, (a0)+
    move.w  2(a1), d0
    move.l  d0, a1
    dbf     d7, @ScanFiles
    
    moveq   #0, d0                      ; Render all filenames
@RenderFiles:
    move.w  d0, d7
    bsr     DrawFileEntryText
    addq.w  #1, d0
    dbf     d1, @RenderFiles
    
@NoFiles:
    rts                                 ; End of subroutine

;****************************************************************************
; RefreshListTiles
; Redraws the whole file list tiles (*without* rerendering the text).
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

RefreshListTiles:
    moveq   #32-1, d0                   ; Draw all entries
@Loop:
    move.w  d0, d7
    bsr     DrawFileEntryTiles
    dbf     d0, @Loop
    
    rts                                 ; End of subroutine

;****************************************************************************
; DrawFileEntryText
; Draws the text of a single file entry.
;----------------------------------------------------------------------------
; input d7.w ... Entry from the cache (0..31)
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

DrawFileEntryText:
    move.w  d7, -(sp)                   ; So we can later chain with
                                        ; DrawFileEntryTiles
    
    and.w   #$1F, d7                    ; Get pointer to entry
    move.w  d7, d6
    add.w   d6, d6
    lea     (FileListPtr), a6
    move.w  (a6,d6.w), d6
    or.l    #$FFFF0000, d6
    move.l  d6, a6
    
    addq.w  #5, a6                      ; Skip linked list pointers and icon
    
    lea     -$20*FLIST_W(sp), sp        ; Render the filename
    move.l  sp, a5
    move.w  d7, d6
    moveq   #FLIST_W, d7
    move.w  d6, -(sp)
    syscall OS_RENDERTEXT
    move.w  (sp)+, d7
    
    mulu.w  #FLIST_W, d7                ; Get where to load the text
    add.w   #VramFileList, d7
    
    move.l  sp, a6                      ; Load it into VRAM
    moveq   #FLIST_W, d6
    syscall OS_LOADPATTERNS
    lea     $20*FLIST_W(sp), sp
    
    move.w  (sp)+, d7                   ; Go to DrawFileEntryTiles

;****************************************************************************
; DrawFileEntryTiles
; Draws the tiles for a file entry (*without* rerendering the text). Useful
; when the entry just moved or got (de)selected, since text is slow to render
; and it's already in VRAM (so better to reuse it).
;----------------------------------------------------------------------------
; input d7.w ... Entry from the cache (0..31)
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

DrawFileEntryTiles:
    move.w  d7, d6                      ; Only bother drawing the entry
    sub.w   (ScrollPos), d6             ; if it's visible on the list
    cmp.w   #FLIST_H, d6
    blo.s   @Visible
    rts
@Visible:
    
    move.w  d7, d6                      ; Get pointer to entry
    and.w   #$1F, d6
    add.w   d6, d6
    moveq   #-1, d5
    lea     (FileListPtr), a6
    move.w  (a6,d6.w), d5
    move.l  d5, a6
    addq.w  #4, a6
    
    move.w  d7, d5                      ; Check if this entry is selected
    moveq   #-1, d6
    move.w  (FileListNext), d6
    move.l  d6, a5
    move.w  d7, d6
    move.w  d6, d5
    and.w   #7, d5
    lsr.w   #3, d6
    btst.b  d5, (a5,d6.w)
    sne.b   d5
    
    sub.w   (ScrollPos), d7
    and.w   #$1F, d7
    
    moveq   #0, d6                      ; Get icon
    move.b  (a6)+, d6
    add.w   #$8000+VramIcons, d6
    tst.b   d5
    beq.s   @NoHilitIcon
    add.w   #$2000, d6
@NoHilitIcon:
    
    move.w  d7, -(sp)                   ; Draw icon
    move.w  d5, -(sp)
    move.w  d6, a6
    move.w  d7, d6
    moveq   #FLIST_X-1, d7
    add.w   #FLIST_Y, d6
    moveq   #1, d5
    syscall OS_PUTTILE
    move.w  (sp)+, d5
    move.w  (sp)+, d7
    
    move.w  d7, d6                      ; Draw filename
    add.w   #FLIST_Y, d6
    add.w   (ScrollPos), d7
    and.w   #$1F, d7
    mulu.w  #FLIST_W, d7
    add.w   #$8000+VramFileList, d7
    tst.b   d5
    beq.s   @NoHilitName
    add.w   #$2000, d7
@NoHilitName:
    move.w  d7, a4
    moveq   #FLIST_X, d7
    move.w  #FLIST_W, a6
    move.w  d6, -(sp)
    move.w  d5, -(sp)
    moveq   #1, d5
    move.w  d5, a5
    syscall OS_DRAWTILES
    move.w  (sp)+, d5
    move.w  (sp)+, d6
    
    move.w  #VramRow, d7                ; Draw background
    and.w   #1, d5
    add.w   d5, d7
    move.w  d7, a4
    moveq   #FLIST_X-1, d7
    move.w  #FLIST_W, a6
    move.w  #1, a5
    moveq   #0, d5
    syscall OS_FILLTILES
    
@Skip:
    rts                                 ; End of subroutine

;****************************************************************************
; SelectFile
; Selects a file entry from the list.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

SelectFile:
    bsr     DeselectAll                 ; Deselect all entries first
    
    syscall OS_GETEVENTXY               ; Get which row was clicked
    subq.w  #FLIST_Y, d6
    add.w   (ScrollPos), d6
    
    move.w  d6, d5                      ; Mark that entry as selected
    moveq   #-1, d7
    move.w  d6, d7
    lsr.w   #3, d7
    and.w   #7, d6
    add.w   (FileListNext), d7
    move.l  d7, a6
    bset.b  d6, (a6)
    
    bsr     RefreshListTiles            ; Redraw list
    
    syscall OS_BEEP                     ; For now
    rts                                 ; End of subroutine

;****************************************************************************
; DeselectAll
; Marks all files as not selected. Also used to initialize the selection
; list (after the list has just been built).
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

DeselectAll:
    move.w  (NumFiles), d7              ; Check how many bytes to clear
    or.w    #$1F, d7
    addq.w  #1, d7
    lsr.w   #5, d7
    
    moveq   #-1, d6                     ; Mark all entries as unselected
    move.w  (FileListNext), d6
    move.l  d6, a6
    moveq   #0, d6
    subq.w  #1, d7
@Loop:
    move.l  d6, (a6)+
    dbf     d7, @Loop
    
    rts                                 ; End of subroutine

;****************************************************************************
; CalcMaxScroll
; Determines the maximum scrolling position
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

CalcMaxScroll:
    move.w  (NumFiles), d7              ; Determine last scrolling row
    sub.w   #FLIST_H, d7
    bcc.s   @NoUnderflow                ; Negative? Not enough files to
    moveq   #0, d7                      ; scroll at all then
@NoUnderflow:
    
    move.w  d7, (ScrollMax)             ; Store max scroll
    rts                                 ; End of subroutine

;****************************************************************************
; ScrollUp
; Scrolls up the file list by 1 row.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

ScrollUp:
    move.w  (ScrollPos), d6             ; Check if we can scroll up
    bne.s   @ScrollOk
    rts
@ScrollOk:
    
    subq.w  #1, d6                      ; Scroll up 1 row
    move.w  d6, (ScrollPos)
    
    add.w   d6, d6                      ; Cache the pointer to the entry
    lea     (FileListPtr), a6           ; that just scrolled in
    moveq   #-1, d7
    move.w  (a6,d6.w), d7
    move.l  d7, a5
    subq.w  #2, d6
    and.w   #$1F<<1, d6
    move.w  (a5), (a6,d6.w)
    
    lsr.w   #1, d6                      ; Render the text for new entry
    move.w  d6, d7
    bsr     DrawFileEntryText
    
    bsr     RefreshListTiles            ; Redraw list
    bra     UpdateScroller              ; Update scroller position

;****************************************************************************
; ScrollDown
; Scrolls down the file list by 1 row.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

ScrollDown:
    move.w  (ScrollPos), d6             ; Can we scroll down?
    cmp.w   (ScrollMax), d6
    blo.s   @ScrollOk
    rts
@ScrollOk:
    
    addq.w  #1, d6                      ; Scroll down 1 row
    move.w  d6, (ScrollPos)
    
    add.w   #FLIST_H-2, d6              ; Cache the pointer to the entry
    add.w   d6, d6                      ; that just scrolled in
    lea     (FileListPtr), a6
    moveq   #-1, d7
    move.w  (a6,d6.w), d7
    move.l  d7, a5
    addq.w  #2, d6
    and.w   #$1F<<1, d6
    move.w  2(a5), (a6,d6.w)
    
    lsr.w   #1, d6                      ; Render the text for new entry
    move.w  d6, d7
    bsr     DrawFileEntryText
    
    bsr     RefreshListTiles            ; Redraw list
    bra     UpdateScroller              ; Update scroller position

;****************************************************************************
; ScrollUpButton
; Code for the scroll down button.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

ScrollUpButton:
    tst.b   (ScrollDelay)               ; Don't scroll too fast!
    beq.s   @DoScroll
    subq.b  #1, (ScrollDelay)
    rts
@DoScroll:
    
    move.b  #3, (ScrollDelay)           ; OK scroll then
    bra     ScrollUp

;****************************************************************************
; ScrollDownButton
; Code for the scroll down button.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

ScrollDownButton:
    tst.b   (ScrollDelay)               ; Don't scroll too fast!
    beq.s   @DoScroll
    subq.b  #1, (ScrollDelay)
    rts
@DoScroll:
    
    move.b  #3, (ScrollDelay)           ; OK scroll then
    bra     ScrollDown

;****************************************************************************
;****************************************************************************

UpdateScroller:
    move.w  (ScrollMax), d7             ; Check if it can even scroll
    beq.s   @CantScroll
    
    move.w  (ScrollPos), d6             ; Determine scroller position
    mulu.w  #SCROLL_LEN*8, d6           ; in pixels
    divu.w  d7, d6
    moveq   #ID_SCROLL, d7
    syscall OS_SETSTATE
    
    rts                                 ; End of subroutine

;----------------------------------------------------------------------------

@CantScroll:
    moveq   #ID_SCROLL, d7              ; Set scroller at the top if it
    moveq   #0, d6                      ; can't be scrolled
    syscall OS_SETSTATE
    
    rts                                 ; End of subroutine
