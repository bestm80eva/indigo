FLIST_W:            equ 23              ; Width of list in tiles
FLIST_H:            equ 18              ; Height of list in tiles
FLIST_X:            equ 4               ; X coordinate of list
FLIST_Y:            equ 5               ; Y coordinate of list

;****************************************************************************
; ClearFileList
; Clears the file list.
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

ClearFileList:
    moveq   #0, d7                      ; Clear string offsets
    lea     (FileListPtr), a6
    moveq   #4-1, d6
@ClearOffsets:
    move.l  d7, (a6)+
    move.l  d7, (a6)+
    move.l  d7, (a6)+
    move.l  d7, (a6)+
    dbf     d6, @ClearOffsets
    
    clr.w   (FileListLast)              ; Set up offsets for new entries
    move.w  #FileList&$FFFF, (FileListNext)
    
    clr.l   (FileList)                  ; Make sure the list is empty
    clr.l   (FileList+4)
    clr.w   (NumFiles)
    clr.w   (ScrollPos)
    clr.w   (ScrollMax)
    
    rts                                 ; End of subroutine

;****************************************************************************
; AddFileEntry
; Adds a filename to the file list.
;----------------------------------------------------------------------------
; input a6.l ... Pointer to filename
; input d7.b ... Icon to show
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

AddFileEntry:
    moveq   #-1, d6                     ; Get pointer to new and last entries
    move.w  (FileListNext), d6
    move.l  d6, a5
    move.w  (FileListLast), d6
    
    beq.s   @NoLastEntry                ; Link the two entries
    move.l  d6, a4
    move.w  (FileListNext), 2(a4)
@NoLastEntry:
    move.w  (FileListLast), (a5)+
    clr.w   (a5)+
    
    move.b  d7, (a5)+                   ; Store icon
    move.b  #$20, (a5)+                 ; Store padding space
    
@CopyFilename:                          ; Store filename
    move.b  (a6)+, (a5)+
    bne.s   @CopyFilename
    
    move.w  a5, d7                      ; Pad to an even size if needed
    and.w   #1, d7
    beq.s   @NoPadding
    clr.b   (a5)+
@NoPadding:
    
    move.w  (FileListNext), (FileListLast)  ; Update offsets for inserting
    move.w  a5, (FileListNext)              ; the next entry
    
    addq.w  #1, (NumFiles)              ; Update file count
    rts                                 ; End of subroutine

;****************************************************************************
; RefreshList
; Redraws the whole file list.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

RefreshList:
    moveq   #0, d0                      ; Find first entry to put in
    moveq   #-1, d6                     ; the cache
    lea     (FileList), a1
    move.w  (ScrollPos), d7
    beq.s   @FindSkip
    subq.w  #1, d7
@FindStart:
    move.w  2(a1), d6
    beq.s   @FindSkip
    move.l  d6, a1
    addq.w  #2, d0
    dbf     d7, @FindStart
@FindSkip:
    
    lea     (FileListPtr), a0           ; Cache the offsets to the entries
    moveq   #FLIST_H-1, d7
    moveq   #-1, d6
@ScanFiles:
    and.w   #$1F<<1, d0
    move.w  a1, (a0,d0.w)
    addq.w  #2, d0
    move.w  2(a1), d6
    beq.s   @ScanStop
    move.l  d6, a1
    dbf     d7, @ScanFiles
@ScanStop:
    
    moveq   #FLIST_H-1, d0              ; Rerender whole list
    move.w  (ScrollPos), d1
@RenderFiles:
    move.w  d1, d7
    addq.w  #1, d1
    bsr     DrawFileEntryText
    dbf     d0, @RenderFiles
    
    rts                                 ; End of subroutine

;****************************************************************************
; RefreshListTiles
; Redraws the whole file list tiles (*without* rerendering the text).
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

RefreshListTiles:
    moveq   #FLIST_H-1, d0              ; Draw all entries
    move.w  (ScrollPos), d1
@Loop:
    move.w  d1, d7
    addq.w  #1, d1
    bsr     DrawFileEntryTiles
    dbf     d0, @Loop
    
    rts                                 ; End of subroutine

;****************************************************************************
; DrawFileEntryText
; Draws the text of a single file entry.
;----------------------------------------------------------------------------
; input d7.w ... Entry ID from the *full* list
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

DrawFileEntryText:
    move.w  d7, d6                      ; Only bother drawing the entry
    sub.w   (ScrollPos), d6             ; if it's visible on the list
    cmp.w   #FLIST_H, d6
    blo.s   @Visible
    rts
@Visible:
    
    move.w  d7, -(sp)                   ; So we can later chain with
                                        ; DrawFileEntryTiles
      
    cmp.w   (NumFiles), d7              ; Does this entry exist? (can happen
    blo.s   @EntryExists                ; that it doesn't if the list is
    lea     @FakeEntry(pc), a6          ; too short and the whole thing is
    bra.s   @EntryFetched               ; getting rerendered)
    
@EntryExists:
    and.w   #$1F, d7                    ; Get pointer to entry
    move.w  d7, d6
    add.w   d6, d6
    lea     (FileListPtr), a6
    moveq   #-1, d5
    move.w  (a6,d6.w), d5
    move.l  d5, a6
    
@EntryFetched:
    addq.w  #5, a6                      ; Skip linked list pointers and icon
    
    lea     -$20*FLIST_W(sp), sp        ; Render the filename
    move.l  sp, a5
    move.w  d7, d6
    moveq   #FLIST_W, d7
    move.w  d6, -(sp)
    syscall OS_RENDERTEXT
    move.w  (sp)+, d7
    
    and.w   #$1F, d7                    ; Get where to load the text
    mulu.w  #FLIST_W, d7
    add.w   #VramFileList, d7
    
    move.l  sp, a6                      ; Load it into VRAM
    moveq   #FLIST_W, d6
    syscall OS_LOADPATTERNS
    lea     $20*FLIST_W(sp), sp
    
    move.w  (sp)+, d7                   ; Go to DrawFileEntryTiles
    bra.s   DrawFileEntryTiles

;----------------------------------------------------------------------------

@FakeEntry:
    dc.w    $0000,$0000,$0000

;****************************************************************************
; DrawFileEntryTiles
; Draws the tiles for a file entry (*without* rerendering the text). Useful
; when the entry just moved or got (de)selected, since text is slow to render
; and it's already in VRAM (so better to reuse it).
;----------------------------------------------------------------------------
; input d7.w ... Entry ID from the *full* list
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

DrawFileEntryTiles:
    move.w  d7, d6                      ; Only bother drawing the entry
    sub.w   (ScrollPos), d6             ; if it's visible on the list
    cmp.w   #FLIST_H, d6
    blo.s   @Visible
    rts
@Visible:
    
    move.w  d7, d6                      ; Get pointer to entry
    and.w   #$1F, d6
    add.w   d6, d6
    moveq   #-1, d5
    lea     (FileListPtr), a6
    move.w  (a6,d6.w), d5
    move.l  d5, a6
    
    moveq   #-1, d6                     ; Check if this entry is selected
    move.w  (FileListNext), d6
    move.l  d6, a5
    move.w  d7, d6
    move.w  d6, d5
    and.w   #7, d5
    lsr.w   #3, d6
    btst.b  d5, (a5,d6.w)
    sne.b   d5
    
    sub.w   (ScrollPos), d7             ; Determine row on screen
    
    moveq   #0, d6                      ; Get icon
    move.b  4(a6), d6
    add.w   #$8000+VramIcons, d6
    tst.b   d5
    beq.s   @NoHilitIcon
    add.w   #$2000, d6
@NoHilitIcon:
    
    move.w  d7, -(sp)                   ; Draw icon
    move.w  d5, -(sp)
    move.w  d6, a6
    move.w  d7, d6
    moveq   #FLIST_X-1, d7
    add.w   #FLIST_Y, d6
    moveq   #1, d5
    syscall OS_PUTTILE
    move.w  (sp)+, d5
    move.w  (sp)+, d7
    
    move.w  d7, d6                      ; Draw filename
    add.w   #FLIST_Y, d6
    add.w   (ScrollPos), d7
    and.w   #$1F, d7
    mulu.w  #FLIST_W, d7
    add.w   #$8000+VramFileList, d7
    tst.b   d5
    beq.s   @NoHilitName
    add.w   #$2000, d7
@NoHilitName:
    move.w  d7, a4
    moveq   #FLIST_X, d7
    move.w  #FLIST_W, a6
    move.w  d6, -(sp)
    move.w  d5, -(sp)
    moveq   #1, d5
    move.w  d5, a5
    syscall OS_DRAWTILES
    move.w  (sp)+, d5
    move.w  (sp)+, d6
    
    move.w  #VramRow, d7                ; Draw background
    and.w   #1, d5
    add.w   d5, d7
    move.w  d7, a4
    moveq   #FLIST_X-1, d7
    move.w  #FLIST_W, a6
    move.w  #1, a5
    moveq   #0, d5
    syscall OS_FILLTILES
    
@Skip:
    rts                                 ; End of subroutine

;****************************************************************************
; SelectFile
; Selects a file entry from the list.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

SelectFile:
    bsr     DeselectAll                 ; Deselect all entries first
    
    syscall OS_GETEVENTXY               ; Get which row was clicked
    subq.w  #FLIST_Y, d6
    add.w   (ScrollPos), d6
    
    move.w  d6, d5                      ; Mark that entry as selected
    moveq   #-1, d7
    move.w  d6, d7
    lsr.w   #3, d7
    and.w   #7, d6
    add.w   (FileListNext), d7
    move.l  d7, a6
    bset.b  d6, (a6)
    
    bsr     RefreshListTiles            ; Redraw list
    
    syscall OS_BEEP                     ; For now
    rts                                 ; End of subroutine

;****************************************************************************
; DeselectAll
; Marks all files as not selected. Also used to initialize the selection
; list (after the list has just been built).
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

DeselectAll:
    move.w  (NumFiles), d7              ; Check how many bytes to clear
    or.w    #$1F, d7
    addq.w  #1, d7
    lsr.w   #5, d7
    
    moveq   #-1, d6                     ; Mark all entries as unselected
    move.w  (FileListNext), d6
    move.l  d6, a6
    moveq   #0, d6
    subq.w  #1, d7
@Loop:
    move.l  d6, (a6)+
    dbf     d7, @Loop
    
    rts                                 ; End of subroutine

;****************************************************************************
; CalcMaxScroll
; Determines the maximum scrolling position
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

CalcMaxScroll:
    move.w  (NumFiles), d7              ; Check if there's enough room to
    cmp.w   #FLIST_H, d7                ; scroll
    bls.s   @CantScroll
    
    sub.w   #FLIST_H, d7                ; Determine last scrolling row
    move.w  d7, (ScrollMax)
    rts
    
@CantScroll:
    clr.w   (ScrollMax)                 ; Can't scroll, force scrolling to
    rts                                 ; be always at 0 then

;****************************************************************************
; ScrollUp
; Scrolls up the file list by 1 row.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

ScrollUp:
    move.w  (ScrollPos), d6             ; Check if we can scroll up
    bne.s   @ScrollOk
    rts
@ScrollOk:
    
    subq.w  #1, d6                      ; Scroll up 1 row
    move.w  d6, (ScrollPos)
    
    addq.w  #1, d6                      ; Cache the pointer to the entry
    add.w   d6, d6                      ; that just scrolled in
    and.w   #$1F<<1, d6
    lea     (FileListPtr), a6
    moveq   #-1, d7
    move.w  (a6,d6.w), d7
    move.l  d7, a5
    subq.w  #2, d6
    and.w   #$1F<<1, d6
    move.w  (a5), (a6,d6.w)
    
    move.w  (ScrollPos), d7             ; Render the text for new entry
    bsr     DrawFileEntryText
    
    bsr     RefreshListTiles            ; Redraw list
    bra     UpdateScroller              ; Update scroller position

;****************************************************************************
; ScrollDown
; Scrolls down the file list by 1 row.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

ScrollDown:
    move.w  (ScrollPos), d6             ; Can we scroll down?
    cmp.w   (ScrollMax), d6
    blo.s   @ScrollOk
    rts
@ScrollOk:
    
    addq.w  #1, d6                      ; Scroll down 1 row
    move.w  d6, (ScrollPos)
    
    add.w   #FLIST_H-2, d6              ; Cache the pointer to the entry
    add.w   d6, d6                      ; that just scrolled in
    and.w   #$1F<<1, d6
    lea     (FileListPtr), a6
    moveq   #-1, d7
    move.w  (a6,d6.w), d7
    move.l  d7, a5
    addq.w  #2, d6
    and.w   #$1F<<1, d6
    move.w  2(a5), (a6,d6.w)
    
    move.w  (ScrollPos), d7              ; Render the text for new entry
    add.w   #FLIST_H-1, d7
    bsr     DrawFileEntryText
    
    bsr     RefreshListTiles            ; Redraw list
    bra     UpdateScroller              ; Update scroller position

;****************************************************************************
; ScrollScroller
; Scrolls when the scroller moves.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

ScrollScroller:
    bsr     ScrollerToPos               ; Get row to scroll to
    
    move.w  d7, d6                      ; Check faster cases (avoid rendering
    sub.w   (ScrollPos), d6             ; the whole list, which is slow)
    beq.s   @NoScroll
    cmp.w   #4, d6                      ; Using unsigned comparisons on these
    bls.s   @FastDown                   ; two so only the -4..+4 range is
    cmp.w   #-4, d6                     ; ever considered (and not any other
    bhs.s   @FastUp                     ; "negative" value). Yeah, exploiting
                                        ; integer wraparound here (that >= -4
                                        ; is actually >= $FFFC).
    
    move.w  d7, (ScrollPos)             ; Scrolled too far, take the
    bra     RefreshList                 ; slow route...

;----------------------------------------------------------------------------

@NoScroll:                              ; Didn't scroll at all, do nothing
    rts

;----------------------------------------------------------------------------

@FastDown:                              ; Scrolled down a bit, only rerender
    subq.w  #1, d6                      ; the rows we scrolled in
@FastDownLoop:
    move.w  d6, -(sp)
    bsr     ScrollDown
    move.w  (sp)+, d6
    dbf     d6, @FastDownLoop
    rts

;----------------------------------------------------------------------------

@FastUp:                                ; Scrolled up a bit, only rerender
    neg.w   d6                          ; the rows we scrolled in
    subq.w  #1, d6
@FastUpLoop:
    move.w  d6, -(sp)
    bsr     ScrollUp
    move.w  (sp)+, d6
    dbf     d6, @FastUpLoop
    rts

;****************************************************************************
; ScrollUpButton
; Code for the scroll down button.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

ScrollUpButton:
    tst.b   (ScrollDelay)               ; Don't scroll too fast!
    beq.s   @DoScroll
    subq.b  #1, (ScrollDelay)
    rts
@DoScroll:
    
    move.b  #3, (ScrollDelay)           ; OK scroll then
    bra     ScrollUp

;****************************************************************************
; ScrollDownButton
; Code for the scroll down button.
;----------------------------------------------------------------------------
; breaks: all
;****************************************************************************

ScrollDownButton:
    tst.b   (ScrollDelay)               ; Don't scroll too fast!
    beq.s   @DoScroll
    subq.b  #1, (ScrollDelay)
    rts
@DoScroll:
    
    move.b  #3, (ScrollDelay)           ; OK scroll then
    bra     ScrollDown

;****************************************************************************
; ScrollerToPos
; Gets to which row one should scroll based on the scroller position.
;----------------------------------------------------------------------------
; output d7.w ... Which row
;----------------------------------------------------------------------------
; breaks: d5-d6, a4-a6
;****************************************************************************

ScrollerToPos:
    moveq   #ID_SCROLL, d7              ; Get scroller position
    syscall OS_GETSTATE
    
    cmp.b   #SCROLL_LEN*8, d7           ; Ensure that the end of the scroller
    bne.s   @NotAtEnd                   ; always goes to the last row
    move.w  (ScrollMax), d7
    rts
@NotAtEnd:
    
    and.w   #$FF, d7
    move.w  (ScrollMax), d6
    mulu.w  d6, d7
    divu.w  #SCROLL_LEN*8, d7
    
    rts                                 ; End of subroutine

;****************************************************************************
; UpdateScroller
; Updates the position of the scrollbar cursor to match the file list.
;----------------------------------------------------------------------------
; breaks: d5-d7, a4-a6
;****************************************************************************

UpdateScroller:
    move.w  (ScrollMax), d7             ; Check if it can even scroll
    beq.s   @CantScroll
    
    move.w  (ScrollPos), d6             ; Determine scroller position
    mulu.w  #SCROLL_LEN*8, d6           ; in pixels
    divu.w  d7, d6
    moveq   #ID_SCROLL, d7
    syscall OS_SETSTATE
    
    rts                                 ; End of subroutine

;----------------------------------------------------------------------------

@CantScroll:
    moveq   #ID_SCROLL, d7              ; Set scroller at the top if it
    moveq   #0, d6                      ; can't be scrolled
    syscall OS_SETSTATE
    
    rts                                 ; End of subroutine
